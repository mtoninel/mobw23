[
  {
    "objectID": "pages/index.html",
    "href": "pages/index.html",
    "title": "Introduction",
    "section": "",
    "text": "The course will give an overview on how to conceptually approach bioinformatics. During the three days of the course we will dive into a bulk RNA-seq experiment and carry out the main steps of a standard data analysis pipeline."
  },
  {
    "objectID": "pages/index.html#day-1",
    "href": "pages/index.html#day-1",
    "title": "Introduction",
    "section": "Day 1",
    "text": "Day 1\n\nSetup RStudio or Posit\nGet familiar with the Posit interface\nLearn about bulk RNA-seq data processing\nDownload the data needed for the workshop"
  },
  {
    "objectID": "pages/index.html#day-2",
    "href": "pages/index.html#day-2",
    "title": "Introduction",
    "section": "Day 2",
    "text": "Day 2\n\nLearn about data normalization\nLearn about the DESeq2 package\nExplore different normalization methods\nNormalize the data with functions provided by the DESeq2 package\nPerform diagnostic and exploratory analysis on the data"
  },
  {
    "objectID": "pages/index.html#day-3",
    "href": "pages/index.html#day-3",
    "title": "Introduction",
    "section": "Day 3",
    "text": "Day 3\n\nLearn about the theory behind differential expression analysis\nPerform differential expression analysis using DESeq2\nVisualize the results\nPerform further downstream analysis on interesting gene groups"
  },
  {
    "objectID": "pages/day1.html",
    "href": "pages/day1.html",
    "title": "Day 1",
    "section": "",
    "text": "Setup RStudio or Posit\nGet familiar with the Posit interface\nLearn about bulk RNA-seq data processing\nDownload the data needed for the workshop"
  },
  {
    "objectID": "pages/day1.html#next-generation-sequencing",
    "href": "pages/day1.html#next-generation-sequencing",
    "title": "Day 1",
    "section": "Next Generation Sequencing",
    "text": "Next Generation Sequencing\nNext Generation Sequencing technologies (Illumina/PacBio) allow experimenters to capture the entire genetic information in a sample in a completely unsupervised manner. The process works with an approach called sequencing-by-synthesis or SBS for short.\n\nüí° Great info can be found at the Illumina Knowledge page\n\nThis means that strands are sequenced by re-building them using the natural complementarity principle of DNA with fluorescently labelled bases. On illumina flow-cells this process happens in clusters, to allow for proper signal amplification and detection, as shown in the movie below."
  },
  {
    "objectID": "pages/day1.html#raw-sequencing-output",
    "href": "pages/day1.html#raw-sequencing-output",
    "title": "Day 1",
    "section": "Raw Sequencing Output",
    "text": "Raw Sequencing Output\nThe raw output of any sequencing run consists of a series of sequences. These sequences can have varying length based on the run parameters set on the sequencing platform. Nevertheless, they are made available to humans to read under a standardized file format known as FASTQ. This is the universally accepted format used to encode sequences after sequencing. An example of real FASTQ file with only two reads is provided below.\n\n@Seq1\nAGTCAGTTAAGCTGGTCCGTAGCTCTGAGGCTGACGAGTCGAGCTCGTACG\n+\nBBBEGGGGEGGGFGFGGEFGFGFGGFGGGGGGFGFGFGGGFGFGFGFGFG\n@Seq2\nTGCTAAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGC\n+\nEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n\nFASTQ files are an intermediate file in the analysis and are used to assess quality metrics for any given sequence. The quality of each base call is encoded in the line after the + following the standard Phred score system."
  },
  {
    "objectID": "pages/day1.html#quality-metrics-inspection",
    "href": "pages/day1.html#quality-metrics-inspection",
    "title": "Day 1",
    "section": "Quality Metrics Inspection",
    "text": "Quality Metrics Inspection\nComputational tools like FastQC aid with the visual inspection of per-sample quality metrics from NGS experiments. Some of the QC metrics of interest to consider include the ones listed below, on the left are optimal metric profiles while on the right are sub-optimal ones:\n\nPer-base Sequence Quality \n\n\nPer-sequence Quality Scores \n\n\nPer-base Sequence Content \n\n\nPer-sequence GC Content \n\n\nSequence Duplication Levels \n\n\nAdapter Content"
  },
  {
    "objectID": "pages/day1.html#read-alignment",
    "href": "pages/day1.html#read-alignment",
    "title": "Day 1",
    "section": "Read Alignment",
    "text": "Read Alignment\nOnce we are satisfied with the quality of our pool of sequences, we need to map them back to the transcripts to which they belonged originally when we produced cDNA molecules from RNA. This process of mapping is needed to understand from which genes were transcripts generated and therefore is an essential and very important step of data processing!\n\n\n\n\nAlignment of trimmed reads to a reference genome or transcriptome.\n\nTools like STAR and BWA-MEM are designed to achieve great speed and accuracy for the computationally expensive task of read alignment.\nThe results of the alignment procedure is a different set of files in SAM (Standard Alignment Map) format which get compressed into their binary representation, BAM files. These are usually one for each analyzed sample and encode the position of all the identified reads along the genome as well as alignment quality metrics for QC, which can be carried out with tools like MultiQC."
  },
  {
    "objectID": "pages/day1.html#counting-transcripts",
    "href": "pages/day1.html#counting-transcripts",
    "title": "Day 1",
    "section": "Counting Transcripts",
    "text": "Counting Transcripts\nAfter sequences have been aligned to their respective place on the genome, it is time to actually count how many times a given sequence is found on any given gene (or transcripts, or exons or others..), this will actually be our gene expression measurement!\n\n\n\nIn the end, for every sample, we will end up with a number for each gene (or transcripts), these are called gene (transcript) counts.\n\nüí° What is the difference between a gene and a transcript?\n\nThese are usually summarized in a table, called gene expression table, where each sample is a column and each row a different gene. We will now load one and take a closer look, this will be our starting point in the hands-on analysis of bulk RNA-seq data."
  },
  {
    "objectID": "pages/day1.html#loading-the-data",
    "href": "pages/day1.html#loading-the-data",
    "title": "Day 1",
    "section": "Loading the data",
    "text": "Loading the data\nWe will load a table of data from this study on tumor-infiltrating CD4+ T-regulatory (Treg) cells. The original data supporting the findings of the study has been deposited on the Gene Expression Omnibus (GEO) data portal under accession number GSE120575. This is the place where all studies publish the processed data from their analysis in order for other researchers to download it and reproduce their findings or test their own hypotheses.\nWe have already downloaded the data and inserted it in a Google Drive folder organizing it as follows:\n\nraw_counts.csv: the gene by sample matrix containing the number of times each gene is detected in each sample (our gene expression values)\nsamples_info.csv: the table containing samples information, known as metadata, which tells us about the biological meaning of each sample\n\nIn the following code chunk, we are going to load the data and create three new variables in our R session, one for each table.\n\n# Load nistalled packages with the \"library()\" function\nlibrary(\"tidyverse\")\nlibrary(\"googledrive\")\n\n# Load files\nfiles <- drive_find(n_max=30)\n\n# File paths with URL\ncounts <- files[files$name == \"raw_counts.csv\",] %>% drive_read_string() %>% read.csv(text = .) %>% as.tibble()\nrownames(counts) <- counts$X\ncounts$X <- NULL\n\nsamples <- files[files$name == \"samples_info.csv\",] %>% drive_read_string() %>% read.csv(text = .) %>% as.tibble()\nrownames(samples) <- samples$X \n\nWe can now explore the data that we have just uploaded in the current R session to familiarize with it.\n\n# Check out the counts\nhead(counts, 10)\n\n# A tibble: 10 √ó 16\n   BSSE_QGF_20‚Ä¶¬π BSSE_‚Ä¶¬≤ BSSE_‚Ä¶¬≥ BSSE_‚Ä¶‚Å¥ BSSE_‚Ä¶‚Åµ BSSE_‚Ä¶‚Å∂ BSSE_‚Ä¶‚Å∑ BSSE_‚Ä¶‚Å∏ BSSE_‚Ä¶‚Åπ\n           <int>   <int>   <int>   <int>   <int>   <int>   <int>   <int>   <int>\n 1             0       0       0       0       0       0       0       0       0\n 2             0       0       0       0       0       0       0       0       0\n 3             0       0       0       0       0       0       0       0       0\n 4             0       0       0       0       0       0       0       0       0\n 5             0       0       0       0       0       0       0       0       0\n 6             0       0       0       0       0       0       0       0       0\n 7             0       0       0       0       0       0       0       0       0\n 8             0       0       0       0       0       0       0       0       0\n 9             0       0       0       0       0       0       0       0       0\n10             0       0       0       0       0       0       0       0       0\n# ‚Ä¶ with 7 more variables: BSSE_QGF_204459 <int>, BSSE_QGF_204460 <int>,\n#   BSSE_QGF_204461 <int>, BSSE_QGF_204462 <int>, BSSE_QGF_204463 <int>,\n#   BSSE_QGF_204464 <int>, BSSE_QGF_204465 <int>, and abbreviated variable\n#   names ¬π‚ÄãBSSE_QGF_204446, ¬≤‚ÄãBSSE_QGF_204447, ¬≥‚ÄãBSSE_QGF_204448,\n#   ‚Å¥‚ÄãBSSE_QGF_204449, ‚Åµ‚ÄãBSSE_QGF_204450, ‚Å∂‚ÄãBSSE_QGF_204451, ‚Å∑‚ÄãBSSE_QGF_204452,\n#   ‚Å∏‚ÄãBSSE_QGF_204453, ‚Åπ‚ÄãBSSE_QGF_204458\n\n\nWe can then check the shape of our counts table (i.e.¬†how many different transcripts we are detecting and how many different samples?)\n\n# How many rows and columns does our count table have?\ndim(counts)\n\n[1] 62854    16\n\n\nWe can see that our table contains count information for 62854 genes and 16 samples.\n\nüí° In R, these table object are called data.frames, tibbles are just like them but with some improved functionalities provided by the tidyverse.\n\nWe can also inspect the metadata from the samples which is stored in the samples variable we created above.\n\n# What does the table look like?\nhead(samples, 10)\n\n# A tibble: 10 √ó 9\n   X               group lib.size norm.fac‚Ä¶¬π FileN‚Ä¶¬≤ Exter‚Ä¶¬≥ Sampl‚Ä¶‚Å¥ Donor sex  \n   <chr>           <int>    <int>      <dbl> <chr>   <chr>   <chr>   <chr> <chr>\n 1 BSSE_QGF_204446     1 40969678      1.03  /scico‚Ä¶ HD276_‚Ä¶ Trest   HD276 Male \n 2 BSSE_QGF_204447     1 38734896      0.994 /scico‚Ä¶ HD276_‚Ä¶ Ttumor  HD276 Male \n 3 BSSE_QGF_204448     1 57149808      0.939 /scico‚Ä¶ HD276_‚Ä¶ Teff    HD276 Male \n 4 BSSE_QGF_204449     1 45415276      1.05  /scico‚Ä¶ HD276_‚Ä¶ Tex     HD276 Male \n 5 BSSE_QGF_204450     1 51767738      0.992 /scico‚Ä¶ HD280_‚Ä¶ Trest   HD280 Male \n 6 BSSE_QGF_204451     1 49277273      0.973 /scico‚Ä¶ HD280_‚Ä¶ Ttumor  HD280 Male \n 7 BSSE_QGF_204452     1 50049428      1.01  /scico‚Ä¶ HD280_‚Ä¶ Teff    HD280 Male \n 8 BSSE_QGF_204453     1 47970167      1.01  /scico‚Ä¶ HD280_‚Ä¶ Tex     HD280 Male \n 9 BSSE_QGF_204458     1 39639302      1.02  /scico‚Ä¶ HD286_‚Ä¶ Trest   HD286 Male \n10 BSSE_QGF_204459     1 39564107      1.01  /scico‚Ä¶ HD286_‚Ä¶ Ttumor  HD286 Male \n# ‚Ä¶ with abbreviated variable names ¬π‚Äãnorm.factors, ¬≤‚ÄãFileName,\n#   ¬≥‚ÄãExternalSampleName, ‚Å¥‚ÄãSampleGroup\n\n\n\n# What is the shape of this samples table?\ndim(samples)\n\n[1] 16  9\n\n\nIn this case, this samples table has as many rows as there are samples (which in turn is equal to the number of columns in the counts table), with columns containing different types of information related to each of the samples in the analysis\nNow that we have our objects correctly loaded, we can dive into the actual RNA-seq analysis."
  },
  {
    "objectID": "pages/day1.html#using-rstudio-or-posit",
    "href": "pages/day1.html#using-rstudio-or-posit",
    "title": "Day 1",
    "section": "Using Rstudio or Posit",
    "text": "Using Rstudio or Posit\nIf RStudio is not installed on your computer, you can create a free account on posit.cloud. Create the account with your credentials and follow the instructions to create a new project. Once done, you should see something like this on your screen:"
  },
  {
    "objectID": "pages/day1.html#communicating-with-r",
    "href": "pages/day1.html#communicating-with-r",
    "title": "Day 1",
    "section": "Communicating with R",
    "text": "Communicating with R\nYou should see your cursor on the left-hand side of the screen blinking. That window represents the R console. It can be used to ‚Äútalk‚Äù with R through commands that it can understand!\nFor example, try typing the following in the console and check what comes out (a.k.a. the output):\n\n# Tell R to print out some words on screen with the \"print\" command\nprint('Hello World!')\n\n[1] \"Hello World!\"\n\n\nYou have now instructed R to do something for you! We will ask it to do plenty more in the code chunks below!"
  },
  {
    "objectID": "pages/day1.html#creating-a-script",
    "href": "pages/day1.html#creating-a-script",
    "title": "Day 1",
    "section": "Creating a script",
    "text": "Creating a script\nIn the console we can type as many commands as we want and execute them sequentially. Nevertheless, commands are lost the moment they are executed and if we want to execute them again we need to type everything back in the console‚Ä¶ this is painful!\nA script is just a normal text file which groups a series of commands that R executes sequentially, reading the file line-by-line. This is much better because we can then edit the file and keep save the changes! Follow the movie below to create an R script in Posit, the same applies to Rstudio.\n\n\n\n\n\nThe new window that appeared on the upper left represents your R script, you can see it from the .R file extension at the end. In here we can write R code which DOES NOT get executed immediately like in the console before.\n\nüí° In order to execute code from the script, highlight the code line you want to execute (or put your cursor line on it) and press ‚åò+Enter on Mac or Ctrl+Enter on Windows."
  },
  {
    "objectID": "pages/day1.html#installing-packages",
    "href": "pages/day1.html#installing-packages",
    "title": "Day 1",
    "section": "Installing packages",
    "text": "Installing packages\nThe analyses that we are going to conduct require specific packages. In R, packages are collections of functions which help us perform standardized workflows. In the code chunk below, we instruct R to install the packages that we need for the analyses.\n\nüí° Copy and paste code chunks from here to your R script to follow.\n\n\n# Install packages from CRAN\ninstall.packages(\"tidyverse\", type=\"source\")\n\n# Install packages from Bioconductor\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nBiocManager::install(\"DESeq2\")\nBiocManager::install(\"vsn\")\n\n# For visualizations\ninstall.packages(\"hexbin\")\ninstall.packages(\"pheatmap\")\ninstall.packages(\"RColorBrewer\")\ninstall.packages(\"ggrepel\")\n\n# For conversion between gene IDs\nBiocManager::install(\"org.Hs.eg.db\")\n\n# For downstream analyses\ninstall.packages(\"msigdbr\")\nBiocManager::install(\"fgsea\")\nBiocManager::install(\"clusterProfiler\")\n\nDuring the installation, you will see many messages being displayed on your R console, don‚Äôt pay too much attention to them unless they are red and specify an error!\nIf you encounter any of these messages during isntallation, follow this procedure here:\n\n# R asks for package updates, answer \"n\" and type enter\n# Question displayed:\nUpdate all/some/none? [a/s/n]:\n\n# Answer to type:  \nn\n\n# R asks for installation from binary source, answer \"no\" and type enter\n# Question displayed:\nDo you want to install from sources the packages which need compilation? (Yes/no/cancel)\n\n# Answer to type:\nno\n\nHopefully all packages were correctly installed and now we can dive a bit deeper into the theoretical basics of RNA sequencing!"
  },
  {
    "objectID": "pages/day2.html",
    "href": "pages/day2.html",
    "title": "Day 2",
    "section": "",
    "text": "Learn about data normalization\nLearn about the DESeq2 package\nExplore different normalization methods\nNormalize the data with functions provided by the DESeq2 package\nPerform diagnostic and exploratory analysis on the data"
  },
  {
    "objectID": "pages/day2.html#why-do-we-need-it",
    "href": "pages/day2.html#why-do-we-need-it",
    "title": "Day 2",
    "section": "Why Do We Need It?",
    "text": "Why Do We Need It?\nNormalization is the process by which we try to conform count data to make it comparable across samples and even across different genes. This is done to ensure that all of the uninteresting differences between genes are minimized in favor of the interesting biological differences that we are interested in.\nThe main factors to take into account when normalizing data are:\n\nSequencing Depth:\n\n\n\nDifferences in sequencing depth (total number of reads in a sample) can cause genes to appear differentially expressed just due to technical reasons.\n\n\nGene Length:\n\n\n\nDifferences in gene length means that longer genes are prone to have more reads coming from them, therefore we need to normalize also for this aspect while processing data.\n\n\nRNA Composition:\n\n\n\nDifferences in RNA composition are also causative of technical artefacts which can skew the analyses. Differences in the number of genes expressed between samples and the number of differentially expressed gene across samples can greatly and negatively impact normalization methods In the example, the majority of counts for sample A is related to the DE gene and therefore this might cause other genes to be normalized by this high number of counts, resulting in them appearing to be expressed at a lower level as opposed to the same genes in sample B."
  },
  {
    "objectID": "pages/day2.html#normalization-strategies",
    "href": "pages/day2.html#normalization-strategies",
    "title": "Day 2",
    "section": "Normalization Strategies",
    "text": "Normalization Strategies\nDuring the years, many approaches to data normalization have been attempted and are summarized in the table below. You can see that they try to tackle each one of the issues we highlighted above.\n\n\n\nNormalization Method\nAccounted Factors\nDescription\n\n\n\n\nCPM (counts per million)\nSequencing depth\nCounts scaled by total read number\n\n\nTPM (transcripts per million)\nSequencing depth and gene length\nCounts per length of transcript (kb) per million mapped reads\n\n\nFPKM/RPKM\nSequencing depth and gene length\nCounts per kilobase of exon mapped reads per million mapped reads\n\n\nDESeq2‚Äôs median of ratios1\nSequencing depth and RNA composition\nCounts are divided by a sample-specific size factor\n\n\nedgeR‚Äôs trimmed mean of M values2\nSequencing depth, RNA composition and gene length\nWeighted trimmed mean of the log ratio of expression between samples\n\n\n\nOut of all these, we will use one of the more advanced ones provided in the DESeq2 R package which will be now introduced."
  },
  {
    "objectID": "pages/day2.html#introduction",
    "href": "pages/day2.html#introduction",
    "title": "Day 2",
    "section": "Introduction",
    "text": "Introduction\nOne of the main interests behind performing a bulk RNA experiment is understanding which genes are more or less expressed across a set of conditions of interest, so we will compare gene expression levels and statistically assess and quantify differences arising between the conditions represented by our categories of samples. In this section we will start getting a feel for what DESeq2 is and how to use it to perform normalization and differential expression analysis on our bulk RNA seq data.\n\nüí° Detailed explanations of the statistical procedures implemented in the package are available in the package‚Äôs vignette.\n\nWe will start by loading the package that we installed in yesterday‚Äôs initial ‚Äúsetup‚Äù section:\n\nlibrary(tidyverse)\nlibrary(DESeq2)\n\nThe package contains many functionalities which are very helpful when dealing with tables of count data, we can inspect them all by typing the following command:\n\n# This should open a popup window in the lower right part of the screen displaying the functions in the package\n??DESeq\n\nIn the sections below, we will follow the standard analysis workflow suggested by the DESeq2 developers."
  },
  {
    "objectID": "pages/day2.html#create-a-deseqdataset-object",
    "href": "pages/day2.html#create-a-deseqdataset-object",
    "title": "Day 2",
    "section": "Create a DESeqDataSet object",
    "text": "Create a DESeqDataSet object\nIn order for the package to read and understand our data and correctly perform the analysis, we need to organize it in a way that the functions of the package can handle. This new object that we are going to create is called DESeqDataSet and there is a utility function to create one starting from the ingredients we currently have, a table of counts (our matrix), a table with sample information (our coldata) and one last thing that we need to decide in order tell the package what comparisons we value the most, this is called a design formula.\nThe design formula should contain the name of a column of interest in our table of samples which contains the information related to the levels we want to contrast. Let‚Äôs say that we have a dataset with two conditions (condition_1 vs condition_2) that we want to compare. The (simplified) samples table will look like this, with three replicates for each of the two conditions:\n\n\n\nSample Code\nPatient\nCondition\n\n\n\n\nSA1\nPt1\nCondition_1\n\n\nSA2\nPt2\nCondition_1\n\n\nSA3\nPt3\nCondition_1\n\n\nSA4\nPt4\nCondition_2\n\n\nSA5\nPt5\nCondition_2\n\n\nSA6\nPt6\nCondition_2\n\n\n\nIf we are interested in performing a differential expression analysis comparing condition_1 versus condition_2, then our design formula should specify the Condition column.\n\nüí° What is the column that we are interested in when specifying the design formula using in our samples table?\n\nNow that we also understand the design formula, we can create the DESeqDataSet object with the data that we loaded beforehand, but first we need to check that the columns of the counts table are in the same order of the rows of the sample table, this is important since we want to be sure that the right levels of expression are associated to the right sample.\n\nall(rownames(samples) == colnames(counts))\n\n[1] TRUE\n\n\nNow we are sure about that we can actually build the object:\n\n# Create a variable containing the design formula\ndesign_formula <-  ~ Donor + SampleGroup \n\n# Create a `DESeqDataSet` object and call it dds\ndds <- DESeqDataSetFromMatrix(countData = counts, \n                              colData = samples, \n                              design = design_formula)\n\nGreat! You have created a DESeqDataSet object which we called dds, this contains all the information related to the counts table and the sample information table in one spot."
  },
  {
    "objectID": "pages/day2.html#filtering-genes",
    "href": "pages/day2.html#filtering-genes",
    "title": "Day 2",
    "section": "Filtering genes",
    "text": "Filtering genes\nWe can the inspect the size of our dds object to check how many genes and samples we have, you can see that this mirrors exactly the counts table that we had previously before incorporating it into the object.\n\ndim(counts(dds))\n\n\nüí° Notice how we used DESeq2‚Äôs function counts() to access the table of gene counts within the DESeqDataSet object.\n\nNow we can start removing some genes which are expressed at low levels. This action is justified both from the biological and the statistical point of view. Biologically, lowly expressed genes are less interesting while statistically, they do not provide enough sampling power to confidently test them for differential expression. In the following chunk we filter our dds object by keeping only genes (rows) which have at least 10 detected counts when summing across all samples.\n\ndds <- dds[rowSums(counts(dds)) >= 10,]\n\n\nüí° This is somewhat of an ‚Äúeasy‚Äù filtering strategy, there are many more complex ones available but sometimes it‚Äôs best to keep things simple!\n\nLet‚Äôs check how many genes we‚Äôre left with after filtering:\n\ndim(dds)\n\n[1] 31737    16\n\n\nYou can see that we have cut the number of genes in our dataset by almost half, now we have 31737 genes."
  },
  {
    "objectID": "pages/day2.html#normalizing-count-data",
    "href": "pages/day2.html#normalizing-count-data",
    "title": "Day 2",
    "section": "Normalizing Count Data",
    "text": "Normalizing Count Data\nAs we have discussed above, normalization is an integral step to the downstream analysis of bulk RNA-seq data. In this section we will normalize our data using the estimateSizeFactors function of the package. This function creates a value for every gene (a pseudovalue) by taking the geometric mean of expression values across samples for that specific gene and then dividing each value by this new computed pseudovalue. This function returns a normalized table of values which is identical in shape to our original counts table as we will see.\n\n# Call the function to normalize count data\ndds <- estimateSizeFactors(dds)\n\nWe can check the values of the computed size factors by doing the following, note how there are as many size factors as there are samples:\n\nsizeFactors(dds)\n\nBSSE_QGF_204446 BSSE_QGF_204447 BSSE_QGF_204448 BSSE_QGF_204449 BSSE_QGF_204450 \n      0.9679699       0.8817713       1.2034053       1.0502422       1.2141002 \nBSSE_QGF_204451 BSSE_QGF_204452 BSSE_QGF_204453 BSSE_QGF_204458 BSSE_QGF_204459 \n      1.0913873       1.1474634       1.0950554       0.9270823       0.8959534 \nBSSE_QGF_204460 BSSE_QGF_204461 BSSE_QGF_204462 BSSE_QGF_204463 BSSE_QGF_204464 \n      0.8036038       0.8165707       0.9341968       1.0681170       1.1779602 \nBSSE_QGF_204465 \n      1.0230975 \n\n\nThe results of the normalization are accessible by using the following code, we will save the normalized values in a different variable that we will call normalized_counts, normalized = TRUE tells DESeq2 to fetch the normalized version of the count table that we have just created above:\n\nnormalized_counts <- counts(dds, normalized = TRUE)\n\n\nüí° NOTE: Although DESeq2 does not use normalized counts as input (the normalization process happens inside automatically), the normalized counts we just generated are definitely useful when plotting results and performing clustering."
  },
  {
    "objectID": "pages/day2.html#transforming-count-data",
    "href": "pages/day2.html#transforming-count-data",
    "title": "Day 2",
    "section": "Transforming Count Data",
    "text": "Transforming Count Data\nAfter we have normalized our data, we need to perform a transformation. There are many ways to transform count data but all of them achieve the goal of removing the gene-wise dependence between variance and mean of expression values across samples (something called homoscedasticity) in order to highlight interesting and biologically relevant expression trends even for genes expressed at lower values. We transform the data using a function provided in the DESeq2 package called rlog which stands for regularized logarithm, without getting too much into the details of the workings of the function, we will transform the data and then look at how the gene-wise relationship between the mean and variance in our normalized data changes before and after the transformation.\n\nlibrary(vsn)\n\n# Plot before data transformation\nmeanSdPlot(assay(dds))\n\n\n\n\n\n\n\n\nTransform the data and then plot the mean/standard deviation relationship after the transformation.\n\n# Transform the data (watch how we create a new variable for it)\nrld <- rlog(dds)\n\n# Check out the transformed values (notice how we now have floating point values and some are even negative!)\nhead(assay(rld), 3)\n\n                BSSE_QGF_204446 BSSE_QGF_204447 BSSE_QGF_204448 BSSE_QGF_204449\nENSG00000229851      -0.3526715      -0.2010792      -0.3602817       -0.355597\nENSG00000228459       0.6365877       1.0374420       0.8520685        0.987522\nENSG00000182888       4.2882919       4.3946526       4.6839023        3.879272\n                BSSE_QGF_204450 BSSE_QGF_204451 BSSE_QGF_204452 BSSE_QGF_204453\nENSG00000229851      -0.2399632      0.08471792      -0.3586727      -0.2279047\nENSG00000228459       0.8502031      0.87305734       0.6243727       0.8723249\nENSG00000182888       4.2302617      3.95351415       4.3661274       4.0408208\n                BSSE_QGF_204458 BSSE_QGF_204459 BSSE_QGF_204460 BSSE_QGF_204461\nENSG00000229851       -0.351090     -0.07393374      -0.1890122      -0.3463143\nENSG00000228459        1.218654      0.64236236       0.6506968       0.9392950\nENSG00000182888        4.731295      4.26397914       4.3844344       3.9801799\n                BSSE_QGF_204462 BSSE_QGF_204463 BSSE_QGF_204464 BSSE_QGF_204465\nENSG00000229851      -0.2084209      -0.3561915     -0.02787813      -0.2197011\nENSG00000228459       1.3012398       0.6294317      0.85659865       0.9948364\nENSG00000182888       4.3140752       4.2895333      4.28450881       4.4216270\n\n\n\n# let's plot the transformed values\nmeanSdPlot(assay(rld))"
  },
  {
    "objectID": "pages/day2.html#data-quality-visual-assessment",
    "href": "pages/day2.html#data-quality-visual-assessment",
    "title": "Day 2",
    "section": "Data Quality Visual Assessment",
    "text": "Data Quality Visual Assessment\nOne way to understand trends in our data and the present of poor quality or outlier samples is to perform exploratory analyses through visualization. In R in general, data visualization is aided by the presence of many packages (on top the basic plotting functionality) which can handle diverse kinds of data visualization tasks (from traditional plots to visualizing tabular data through heatmaps). We will encounter two of these packages, one is ggplot2 and the other one is pheatmap.\n\nClustering\nOne of the main strategies for checking the consistency of our dataset is to cluster samples based on their complete expression profile (which as you might recall consists of 31737 genes in our dataset). This will allow us to control for presence of outliers in the data and understand if we see consistent profiles of gene expression across replicates, which we expect. Use the code below to plot a heatmap of normalized expression values for our samples. Since plotting the full expression table can be computationally expensive, we might want to subset it to the 200 top expressed genes in the dataset.\n\nlibrary(\"pheatmap\")\n\n# Take the top 200 genes in the dataset\nselect <- order(rowMeans(counts(dds,normalized=TRUE)),\n                decreasing=TRUE)[1:200]\n# Create another table for annotating the heatmap with colors\ndf <- as.data.frame(colData(dds)[,c(\"Donor\",\"SampleGroup\")])\n\n# Draw the heatmap using the `pheatmap` package\npheatmap(assay(rld)[select,], cluster_rows=FALSE, show_rownames=FALSE,\n         cluster_cols=TRUE, annotation_col=df)\n\n\n\n\n\n\n\n\n\nüí° What type of assessment would you make about the consistency of the samples across these top 200 genes? Do they cluster (a synonim for similar) based on the donor or on the biological condition of our interest?\n\n\n\nSample-to-sample Distances\nAnother way to get a sense of the global relationship between samples is to check for how distant samples are between themselves. This analysis of pairwise distances looks at the expression value of all 31737 genes in the dataset and determines which samples have a more or less similar or different expression value for each. We expect biologically similar samples to have very little difference.\n\nlibrary(RColorBrewer)\n\n# Compute distances\nsampleDists <- dist(t(assay(rld)))\n\n# Organize\nsampleDistMatrix <- as.matrix(sampleDists)\n\ncolors <- colorRampPalette( rev(brewer.pal(9, \"Blues\")) )(255)\n\n# Plot with `pheatmap`\npheatmap(sampleDistMatrix,\n         clustering_distance_rows=sampleDists,\n         clustering_distance_cols=sampleDists,\n         color = colors,\n         annotation_col = df)\n\n\n\n\n\n\n\n\n\nüí° What type of assessment would you make about the heatmap you just produced? Which CD8 T-cell populations are mostly similar in terms of overall gene expression profile? Does a particular population stand out?\n\n\n\nPrincipal Component Analysis (PCA)\nAnother useful approach for understanding the variability axes in our data is to compute and plot a PCA. Without getting into the details, PCA takes our expression data and outputs its principal components, which encode the main sources of variability in the data. Ideally, we want the samples to be variable because of the biological effect of our interest (in this case the differences between CD8 T-cell populations), but this might not be the case. By plotting and coloring the points by different covariates (i.e.¬†donor or cell type) we are able to understand where the variability comes from. Use the code below to generate two scatter plots of PCA coordinates and color them to understand where the differences in the data are.\n\nlibrary(ggplot2)\n\n# Calculate principal components and percentage of variance\npcaData <- plotPCA(rld, intgroup=c(\"Donor\",\"SampleGroup\"), returnData=TRUE)\npercentVar <- round(100 * attr(pcaData, \"percentVar\"))\n\n# Plot (this time with ggplot2!!)\nggplot(pcaData, aes(PC1, PC2, color=SampleGroup, shape=Donor)) +\n  geom_point(size=3) +\n  xlab(paste0(\"PC1: \",percentVar[1],\"% variance\")) +\n  ylab(paste0(\"PC2: \",percentVar[2],\"% variance\")) + \n  coord_fixed() +\n  theme_classic()\n\n\n\n\n\n\n\n\n\nüí° What can you say about this PCA? Are the samples positioning themselves based on the donor or their biological condition? What is the most extreme group of samples? How does this information relate to the other plots we produced above?\n\nNow that we have plotted all the main diagnostic information related to the dataset and we have a bit of a grasp of it, we can start thinking about testing for differentially expressed genes."
  },
  {
    "objectID": "pages/day2.html#differential-expression-analysis",
    "href": "pages/day2.html#differential-expression-analysis",
    "title": "Bioinformatics Worskshop 2023",
    "section": "Differential Expression Analysis",
    "text": "Differential Expression Analysis\nThe main purpose of the steps we performed above is to get to this point with a fair knowledge of the data at hand, all the steps have to be repeated each time one starts with some fresh new data (no data is the same!!). Now we can start performing differential expression analysis with the DESeq2 package. The main concept behind it is to contrast two categories of our interest in the data (i.e.¬†CD8+ Tex vs CD8+ Teff) and check which genes are predominantly (defined in a statistical sense) expressed in one category as opposed to the other. As introduced previously, we tell DESeq2 which comparisons to perform through the design formula we specified above when we created our DESeqDataSet object dds. With that design formula we told it we are interested in checking for the gene expression differences happening between the categories present in the SampleGroup column of our samples table. These categories are exactly the ones we have been plotting all along up to this point (the different CD8+ T-cell types).\n\nüí° Given that we have four differences categories (these are also called levels in R) in our SampleGroup column (which can also be called a factor in R), DESeq2 could perform different comparisons since these are pairwise. We will see a way to set up the analysis only for our comparison of interest!\n\n\nThe DESeq() Function\nLet‚Äôs perform differential expression analysis with DESeq2 on our dataset using the main function for the task in the package, DESeq().\n\n# Perform differential expression testing given the design formula we wrote previously\ndds <- DESeq(dds)\n\nNote how we did not use the transformed version of the dataset (rld) but we started from the object dds. As previously mentioned, the package needs to start from raw count data to correctly assess differences in gene expression.\n\n\nPerforming Pairwise Comparisons\nAfter having used the main DESeq() function, we can actively explore the results of the analysis for the comparisons of our interest by using the results function and specifying the contrast argument. Let‚Äôs say that we are very interested in the differences occurring between CD8+ Teff and CD8+ Tex cells. For example we might want to check if any gene is up-regulated during the process of CD8+ T-cell With the alpha parameter we can determine the adjusted P-value threshold used to accept or reject the null hypothesis (\\(H_{0}\\)) of a gene NOT being differentially expressed between the two conditions.\n\n# Perform comparison of interest, in this case we specify the column of interest (SampleGroup) and the two categories we want to compare (Tex, Teff)\nres <- results(dds, contrast=c(\"SampleGroup\",\"Tex\",\"Teff\"), alpha=0.05)\n\n# Check out results object\nres\n\nlog2 fold change (MLE): SampleGroup Tex vs Teff \nWald test p-value: SampleGroup Tex vs Teff \nDataFrame with 31737 rows and 6 columns\n                 baseMean log2FoldChange     lfcSE       stat      pvalue\n                <numeric>      <numeric> <numeric>  <numeric>   <numeric>\nENSG00000229851  0.912955      -0.721460  1.995291  -0.361581 0.717664846\nENSG00000228459  2.007637       1.725303  1.479171   1.166399 0.243453351\nENSG00000182888 20.114262      -0.684108  0.398827  -1.715301 0.086290130\nENSG00000286431 37.737060       1.590643  0.459762   3.459710 0.000540758\nENSG00000237490  1.431632      -1.658804  1.416530  -1.171034 0.241585273\n...                   ...            ...       ...        ...         ...\nENSG00000277196   2.22430     -4.6031382  1.586543 -2.9013632  0.00371543\nENSG00000276256 156.45194     -0.6533130  0.201091 -3.2488471  0.00115874\nENSG00000278457   0.95921     -0.3539669  1.714009 -0.2065140  0.83638940\nENSG00000278384  55.69841      0.6479274  0.287083  2.2569366  0.02401203\nENSG00000278704   2.19671      0.0621554  1.279027  0.0485958  0.96124138\n                      padj\n                 <numeric>\nENSG00000229851         NA\nENSG00000228459 0.34047224\nENSG00000182888 0.14377670\nENSG00000286431 0.00154071\nENSG00000237490         NA\n...                    ...\nENSG00000277196 0.00896232\nENSG00000276256 0.00309143\nENSG00000278457         NA\nENSG00000278384 0.04753364\nENSG00000278704 0.97398928\n\n\nWe can see that the results of our analysis are stored inside a table which we assigned to the variable res. We can additionally print out a summary of the results of the differential analysis results by using the following code:\n\nsummary(res)\n\n\nout of 31737 with nonzero total read count\nadjusted p-value < 0.05\nLFC > 0 (up)       : 7155, 23%\nLFC < 0 (down)     : 6802, 21%\noutliers [1]       : 0, 0%\nlow counts [2]     : 4308, 14%\n(mean count < 2)\n[1] see 'cooksCutoff' argument of ?results\n[2] see 'independentFiltering' argument of ?results\n\n\nIn here we can see the type of comparison we are performing, the P-value threshold we used and the number of up-regulated and down-regulated genes at a log-fold change of 1, which corresponds to a difference in raw gene expression value of 2 times since the log has a base of 2. So, to recap, all of the genes with log-fold change of 1 or more are twice as expressed in one condition compared to the other.\n\n\nVisualizing Results With Volcano Plots\nOnce we have our results from the comparison, we might want to present them graphically to aid their interpretation by other people or to emphasize messages of interest within them (like the statistics only for some genes of interest). One way to visualize results from a differential expression analysis is to draw a volcano plot. The goal of a volcano plot is to display and summarize the main metrics of output from a differential expression analysis, these consist of P-values and log-fold changes associated with each gene in the dataset for the specific comparison we are performing. These two variables can be plotted together to get a feel for the overall results in the analysis. Let‚Äôs plot a volcano summarizing the results of the comparison we have performed.\n\nlibrary(ggrepel)\n\nlog2FC_val = 1\npadj_val = 0.05\n\nvolcano_corr = as.data.frame(res) %>% mutate(names=rownames(res)) %>% drop_na()\n\nvolcano_corr$threshold=ifelse(volcano_corr$log2FoldChange >= log2FC_val & volcano_corr$padj < padj_val,\"A\",\n                         ifelse(volcano_corr$log2FoldChange <= -log2FC_val & volcano_corr$padj < padj_val, \"B\",\"C\"))\n\nggplot(volcano_corr, aes(x=log2FoldChange, y =-log10(padj), color=threshold)) +\n    geom_point(alpha=0.9, size=3) +\n    scale_color_manual(values=c( \"B\"=\"#3891A6\",\"A\"=\"#C52233\", \"C\"=\"grey\")) + \n    #scale_color_manual(values=c( \"mark\"=\"black\", \"leave\"=\"white\")) + \n    xlab(\"log2(Fold Change)\") + ylab(\"-log10(adj p-value)\") +\n    theme_minimal() +\n    geom_vline(xintercept=0, color='black') +\n    geom_hline(yintercept=0, color='black') +\n    theme(legend.position=\"none\", axis.title.x = element_text(size = 17),\n                axis.text.y=element_text(size = 0),\n                axis.text.x=element_text(size = 17),\n               axis.title.y = element_text(size = 15)) \n\n\n\n\n\n\n\n\n\n\nMapping IDs to Gene Symbols\nThe volcano plot above is nice but it is not so informative since we cannot see any gene name! Unfortunately we do not have recognizable gene names in the res object, as we can see below:\n\n# In this case gene names are the names of the rows of our table\nrownames(res)[1:20]\n\n [1] \"ENSG00000229851\" \"ENSG00000228459\" \"ENSG00000182888\" \"ENSG00000286431\"\n [5] \"ENSG00000237490\" \"ENSG00000101846\" \"ENSG00000285679\" \"ENSG00000219870\"\n [9] \"ENSG00000101849\" \"ENSG00000047644\" \"ENSG00000073464\" \"ENSG00000004961\"\n[13] \"ENSG00000005302\" \"ENSG00000169933\" \"ENSG00000101911\" \"ENSG00000229083\"\n[17] \"ENSG00000196664\" \"ENSG00000205542\" \"ENSG00000289596\" \"ENSG00000261030\"\n\n\nWe can see that we currently have Ensembl Gene IDs as opposed to gene symbols! We can fix this by converting between the two, this can be achieved in R through dedicated packages like org.Hs.eg.db which map between the two types of gene identifiers. Let‚Äôs do it using the code below.\n\n# Use the package for the conversion between Ensembl IDs and Gene Symbols\nlibrary(org.Hs.eg.db)\n\nvolcano_corr$gene_names <- mapIds(org.Hs.eg.db, keys=row.names(volcano_corr), column=\"SYMBOL\", keytype=\"ENSEMBL\", multiVals=\"first\")\n\nWe can now check that we have new mapped gene symbols that we can use to make our volcano plot informative!\n\nvolcano_corr$gene_names[1:40] \n\n [1] NA            \"RPS27AP20\"   NA            \"STS\"         NA           \n [6] \"TBL1X\"       \"WWC3\"        \"CLCN4\"       \"HCCS\"        \"MSL3\"       \n[11] \"FRMPD4\"      \"PRPS2\"       NA            \"TLR7\"        \"TMSB4X\"     \n[16] NA            NA            \"GS1-600G8.3\" NA            \"LINC01203\"  \n[21] \"EGFL6\"       \"TCEANC\"      \"RAB9A\"       \"OFD1\"        NA           \n[26] NA            \"MOSPD2\"      \"CA5BP1\"      \"CA5B\"        \"ZRSR2\"      \n[31] NA            \"GRPR\"        \"SYAP1\"       \"TXLNG\"       NA           \n[36] \"NHS\"         \"SCML1\"       NA            \"CDKL5\"       NA           \n\n\nAnd finally we can try to plot again our volcano with the addition of gene names!\n\nvolcano_corr <- volcano_corr[order(volcano_corr$padj, decreasing = FALSE),] %>% drop_na()\n\nnames_list <- c(volcano_corr$gene_names[1:10], \"TOX\", \"ENTPD1\", \"HAVCR2\")\n\nneg_fc <- volcano_corr[order(volcano_corr$log2FoldChange, decreasing = TRUE),] %>% filter(padj < 0.05 ) %>% .$gene_names %>% head(10) # Change these numbers to avoid overcrowding in the plot\npos_fc <- volcano_corr[order(volcano_corr$log2FoldChange, decreasing = FALSE),] %>% filter(padj < 0.05) %>% .$gene_names %>% head(10)\n\nnames_list <- c(names_list, neg_fc, pos_fc)\n  \nvolcano_corr <- volcano_corr %>% mutate(., stroke = ifelse(.$gene_names %in% names_list & volcano_corr$padj < padj_val & volcano_corr$log2FoldChange > log2FC_val, 2, 0), \n                                               names=ifelse(.$gene_names %in% names_list,'mark','leave')) %>%\n                                                    .[order(.$names),]\n\nggplot(volcano_corr, aes(x=log2FoldChange, y =-log10(padj), color=threshold)) +\n    geom_point(alpha=0.9, size=3) +\n    scale_color_manual(values=c( \"B\"=\"#3891A6\",\"A\"=\"#C52233\", \"C\"=\"grey\")) + \n    xlab(\"log2(Fold Change)\") + ylab(\"-log10(adj p-value)\") +\n    theme_minimal() +\n    geom_vline(xintercept=0, color='black') +\n    geom_hline(yintercept=0, color='black') +\n    theme(legend.position=\"none\", axis.title.x = element_text(size = 17),\n                axis.text.y=element_text(size = 0),\n                axis.text.x=element_text(size = 17),\n               axis.title.y = element_text(size = 15)) +\n    geom_label_repel(data=volcano_corr[which(volcano_corr$names=='mark' & volcano_corr$threshold=='A'),], aes(label=gene_names), max.overlaps = 30, color='black', size=4, fill='white', fontface='italic') +\n    geom_label_repel(data=volcano_corr[which(volcano_corr$names=='mark' & volcano_corr$threshold=='B'),], aes(label=gene_names), max.overlaps = 30, color='black', size=4, fill='white', fontface='italic')\n\n\n\n\n\n\n\n\n\n\nVisualizing Results With Heatmaps\nWe can also plot differentially expressed genes in the two conditions of our interest using heatmaps. In this case we select genes based on their significance and visualize how their expression values change across samples just like we have done earlier.\n\n# Check conditions of interest\nconds <- c(\"Teff\",\"Tex\")\n\n# Take genes\ndiffs <- rbind(volcano_corr[volcano_corr$threshold == \"A\",], volcano_corr[volcano_corr$threshold == \"B\",])$gene_names\n\n# Extract counts from `dds` object\nmtx <- counts(dds, normalized=TRUE)[,rownames(samples[which(samples$SampleGroup %in% conds),])]\n\n# Subset for differential genes \nids <- rownames(volcano_corr[which(volcano_corr$gene_names %in% diffs),])\n\n# Subset matrix for genes of interest\nmtx <- mtx[ids,]\n\n# Plot with pheatmap\npheatmap(mtx, cluster_rows=TRUE, show_rownames=FALSE,\n         cluster_cols=TRUE, annotation_col=df[which(rownames(df) %in% colnames(mtx)),], scale = \"row\")\n\n\n\n\n\n\n\n\nGiven that the number of differentially expressed genes can sometimes be very high, we cannot pretend to explore them manually one by one understanding their function! As we will see, there are further downstream analyses we can perform to get a sense of trends and pathways activated in the cell type of our interest. These analyses which look at genes in groups or ontologies try to match conditions with functions, to better elucidate what is going on inside cells in a specific condition."
  },
  {
    "objectID": "pages/day3.html",
    "href": "pages/day3.html",
    "title": "Day 3",
    "section": "",
    "text": "Learn about the theory behind differential expression analysis\nPerform differential expression analysis using DESeq2\nVisualize the results\nPerform further downstream analysis on interesting gene groups"
  },
  {
    "objectID": "pages/day3.html#differential-expression-analysis",
    "href": "pages/day3.html#differential-expression-analysis",
    "title": "Day 3",
    "section": "Differential Expression Analysis",
    "text": "Differential Expression Analysis\nThe main purpose of the steps we performed above is to get to this point with a fair knowledge of the data at hand, all the steps have to be repeated each time one starts with some fresh new data (no data is the same!!). Now we can start performing differential expression analysis with the DESeq2 package. The main concept behind it is to contrast two categories of our interest in the data (i.e.¬†CD8+ Tex vs CD8+ Teff) and check which genes are predominantly (defined in a statistical sense) expressed in one category as opposed to the other. As introduced previously, we tell DESeq2 which comparisons to perform through the design formula we specified above when we created our DESeqDataSet object dds. With that design formula we told it we are interested in checking for the gene expression differences happening between the categories present in the SampleGroup column of our samples table. These categories are exactly the ones we have been plotting all along up to this point (the different CD8+ T-cell types).\n\nüí° Given that we have four differences categories (these are also called levels in R) in our SampleGroup column (which can also be called a factor in R), DESeq2 could perform different comparisons since these are pairwise. We will see a way to set up the analysis only for our comparison of interest!\n\n\nThe DESeq() Function\nLet‚Äôs perform differential expression analysis with DESeq2 on our dataset using the main function for the task in the package, DESeq().\n\n# Perform differential expression testing given the design formula we wrote previously\ndds <- DESeq(dds)\n\nNote how we did not use the transformed version of the dataset (rld) but we started from the object dds. As previously mentioned, the package needs to start from raw count data to correctly assess differences in gene expression.\n\n\nPerforming Pairwise Comparisons\nAfter having used the main DESeq() function, we can actively explore the results of the analysis for the comparisons of our interest by using the results function and specifying the contrast argument. Let‚Äôs say that we are very interested in the differences occurring between CD8+ Teff and CD8+ Tex cells. For example we might want to check if any gene is up-regulated during the process of CD8+ T-cell With the alpha parameter we can determine the adjusted P-value threshold used to accept or reject the null hypothesis (\\(H_{0}\\)) of a gene NOT being differentially expressed between the two conditions.\n\n# Specify conditions to compare\nconds <- c(\"Ttumor\",\"Teff\")\n\n# Perform comparison of interest, in this case we specify the column of interest (SampleGroup) and the two categories we want to compare (Tex, Teff)\nres <- results(dds, contrast=c(\"SampleGroup\",conds[1],conds[2]), alpha=0.05)\n\n# Check out results object\nres\n\nlog2 fold change (MLE): SampleGroup Ttumor vs Teff \nWald test p-value: SampleGroup Ttumor vs Teff \nDataFrame with 62854 rows and 6 columns\n                 baseMean log2FoldChange     lfcSE      stat    pvalue\n                <numeric>      <numeric> <numeric> <numeric> <numeric>\nENSG00000228572         0             NA        NA        NA        NA\nENSG00000182378         0             NA        NA        NA        NA\nENSG00000226179         0             NA        NA        NA        NA\nENSG00000281849         0             NA        NA        NA        NA\nENSG00000280767         0             NA        NA        NA        NA\n...                   ...            ...       ...       ...       ...\nENSG00000278457   0.95921       0.544214  1.633402  0.333178  0.739000\nENSG00000278294   0.00000             NA        NA        NA        NA\nENSG00000278384  55.69841       0.448235  0.289744  1.547000  0.121863\nENSG00000278625   0.00000             NA        NA        NA        NA\nENSG00000278704   2.19671      -0.312679  1.315100 -0.237760  0.812067\n                     padj\n                <numeric>\nENSG00000228572        NA\nENSG00000182378        NA\nENSG00000226179        NA\nENSG00000281849        NA\nENSG00000280767        NA\n...                   ...\nENSG00000278457        NA\nENSG00000278294        NA\nENSG00000278384  0.191400\nENSG00000278625        NA\nENSG00000278704  0.864462\n\n\nWe can see that the results of our analysis are stored inside a table which we assigned to the variable res. We can additionally print out a summary of the results of the differential analysis results by using the following code:\n\nsummary(res)\n\n\nout of 42562 with nonzero total read count\nadjusted p-value < 0.05\nLFC > 0 (up)       : 7236, 17%\nLFC < 0 (down)     : 7414, 17%\noutliers [1]       : 0, 0%\nlow counts [2]     : 14481, 34%\n(mean count < 1)\n[1] see 'cooksCutoff' argument of ?results\n[2] see 'independentFiltering' argument of ?results\n\n\nIn here we can see the type of comparison we are performing, the P-value threshold we used and the number of up-regulated and down-regulated genes at a log-fold change of 1, which corresponds to a difference in raw gene expression value of 2 times since the log has a base of 2. So, to recap, all of the genes with log-fold change of 1 or more are twice as expressed in one condition compared to the other.\nIn the code below, we will create two new tables with the genes that were up-regulated and down-regulated in the comparison we performed, we will use these later.\n\n# Extract the information related to up-regulated and down-regulated genes\nup_df <- res %>% as.data.frame() %>% filter(padj < 0.05 & log2FoldChange > 1)\ndown_df <- res %>% as.data.frame() %>% filter(padj < 0.05 & log2FoldChange < -1)\n\nIf we check the table with the up-regulated genes we can see it has the following structure (we just took some specific rows - genes - of the complete results table corresponding to up-regulated genes):\n\nhead(up_df, 4)\n\n                  baseMean log2FoldChange     lfcSE     stat       pvalue\nENSG00000286431   37.73706       1.472315 0.4612655 3.191903 1.413390e-03\nENSG00000005302 4883.56076       1.155996 0.1213668 9.524813 1.653388e-21\nENSG00000176896  290.20191       1.680612 0.1994530 8.426108 3.573522e-17\nENSG00000224975   83.75517       1.120562 0.2100045 5.335894 9.507474e-08\n                        padj\nENSG00000286431 3.574656e-03\nENSG00000005302 2.955365e-20\nENSG00000176896 4.351608e-16\nENSG00000224975 4.451140e-07\n\n\n\nüí° How would you check if the dimensions of the tables we extracted correspond to the number of differentially expressed genes present in the summary we printed above?\n\n\n\nVisualizing Results With Volcano Plots\nOnce we have our results from the comparison, we might want to present them graphically to aid their interpretation by other people or to emphasize messages of interest within them (like the statistics only for some genes of interest). One way to visualize results from a differential expression analysis is to draw a volcano plot. The goal of a volcano plot is to display and summarize the main metrics of output from a differential expression analysis, these consist of P-values and log-fold changes associated with each gene in the dataset for the specific comparison we are performing. These two variables can be plotted together to get a feel for the overall results in the analysis. Let‚Äôs plot a volcano summarizing the results of the comparison we have performed.\n\nlibrary(ggrepel)\n\nlog2FC_val = 1\npadj_val = 0.05\n\nvolcano_corr = as.data.frame(res) %>% mutate(names=rownames(res)) %>% drop_na()\n\nvolcano_corr$threshold=ifelse(volcano_corr$log2FoldChange >= log2FC_val & volcano_corr$padj < padj_val,\"A\",\n                         ifelse(volcano_corr$log2FoldChange <= -log2FC_val & volcano_corr$padj < padj_val, \"B\",\"C\"))\n\nggplot(volcano_corr, aes(x=log2FoldChange, y =-log10(padj), color=threshold)) +\n    geom_point(alpha=0.9, size=3) +\n    scale_color_manual(values=c( \"B\"=\"#3891A6\",\"A\"=\"#C52233\", \"C\"=\"grey\")) + \n    #scale_color_manual(values=c( \"mark\"=\"black\", \"leave\"=\"white\")) + \n    xlab(\"log2(Fold Change)\") + ylab(\"-log10(adj p-value)\") +\n    theme_minimal() +\n    geom_vline(xintercept=0, color='black') +\n    geom_hline(yintercept=0, color='black') +\n    theme(legend.position=\"none\", axis.title.x = element_text(size = 17),\n                axis.text.y=element_text(size = 0),\n                axis.text.x=element_text(size = 17),\n               axis.title.y = element_text(size = 15)) \n\n\n\n\n\n\n\n\n\n\nMapping IDs to Gene Symbols\nThe volcano plot above is nice but it is not so informative since we cannot see any gene name! Unfortunately we do not have recognizable gene names in the res object, as we can see below:\n\n# In this case gene names are the names of the rows of our table\nrownames(res)[1:20]\n\n [1] \"ENSG00000228572\" \"ENSG00000182378\" \"ENSG00000226179\" \"ENSG00000281849\"\n [5] \"ENSG00000280767\" \"ENSG00000185960\" \"LRG_710\"         \"ENSG00000237531\"\n [9] \"ENSG00000198223\" \"ENSG00000265658\" \"ENSG00000185291\" \"ENSG00000236871\"\n[13] \"ENSG00000236017\" \"ENSG00000197976\" \"ENSG00000196433\" \"ENSG00000289620\"\n[17] \"ENSG00000223511\" \"ENSG00000234622\" \"ENSG00000277120\" \"ENSG00000223773\"\n\n\nWe can see that we currently have Ensembl Gene IDs as opposed to gene symbols! We can fix this by converting between the two, this can be achieved in R through dedicated packages like org.Hs.eg.db which map between the two types of gene identifiers. Let‚Äôs do it using the code below.\n\n# Use the package for the conversion between Ensembl IDs and Gene Symbols\nlibrary(org.Hs.eg.db)\n\nvolcano_corr$gene_names <- mapIds(org.Hs.eg.db, keys=row.names(volcano_corr), column=\"SYMBOL\", keytype=\"ENSEMBL\", multiVals=\"first\")\n\nWe can now check that we have new mapped gene symbols that we can use to make our volcano plot informative!\n\nvolcano_corr$gene_names[1:40] \n\n [1] NA            \"RPS27AP20\"   NA            NA            \"STS\"        \n [6] NA            \"TBL1X\"       \"WWC3\"        \"CLCN4\"       \"HCCS\"       \n[11] \"MSL3\"        \"FRMPD4\"      \"PRPS2\"       NA            \"TLR7\"       \n[16] \"TMSB4X\"      NA            NA            \"GS1-600G8.3\" NA           \n[21] \"LINC01203\"   \"EGFL6\"       \"TCEANC\"      \"RAB9A\"       \"OFD1\"       \n[26] NA            NA            \"MOSPD2\"      \"CA5BP1\"      \"CA5B\"       \n[31] \"ZRSR2\"       NA            \"GRPR\"        \"SYAP1\"       \"TXLNG\"      \n[36] \"REPS2\"       NA            \"NHS\"         \"SCML1\"       NA           \n\n\nAnd finally we can try to plot again our volcano with the addition of gene names!\n\nvolcano_corr <- volcano_corr[order(volcano_corr$padj, decreasing = FALSE),] %>% drop_na()\n\nnames_list <- c(volcano_corr$gene_names[1:10], \"TOX\", \"ENTPD1\", \"HAVCR2\")\n\nneg_fc <- volcano_corr[order(volcano_corr$log2FoldChange, decreasing = TRUE),] %>% filter(padj < 0.05 ) %>% .$gene_names %>% head(10) # Change these numbers to avoid overcrowding in the plot\npos_fc <- volcano_corr[order(volcano_corr$log2FoldChange, decreasing = FALSE),] %>% filter(padj < 0.05) %>% .$gene_names %>% head(10)\n\nnames_list <- c(names_list, neg_fc, pos_fc)\n  \nvolcano_corr <- volcano_corr %>% mutate(., stroke = ifelse(.$gene_names %in% names_list & volcano_corr$padj < padj_val & volcano_corr$log2FoldChange > log2FC_val, 2, 0), \n                                               names=ifelse(.$gene_names %in% names_list,'mark','leave')) %>%\n                                                    .[order(.$names),]\n\nggplot(volcano_corr, aes(x=log2FoldChange, y =-log10(padj), color=threshold)) +\n    geom_point(alpha=0.9, size=3) +\n    scale_color_manual(values=c( \"B\"=\"#3891A6\",\"A\"=\"#C52233\", \"C\"=\"grey\")) + \n    xlab(\"log2(Fold Change)\") + ylab(\"-log10(adj p-value)\") +\n    theme_minimal() +\n    geom_vline(xintercept=0, color='black') +\n    geom_hline(yintercept=0, color='black') +\n    theme(legend.position=\"none\", axis.title.x = element_text(size = 17),\n                axis.text.y=element_text(size = 0),\n                axis.text.x=element_text(size = 17),\n               axis.title.y = element_text(size = 15)) +\n    geom_label_repel(data=volcano_corr[which(volcano_corr$names=='mark' & volcano_corr$threshold=='A'),], aes(label=gene_names), max.overlaps = 30, color='black', size=4, fill='white', fontface='italic') +\n    geom_label_repel(data=volcano_corr[which(volcano_corr$names=='mark' & volcano_corr$threshold=='B'),], aes(label=gene_names), max.overlaps = 30, color='black', size=4, fill='white', fontface='italic')\n\n\n\n\n\n\n\n\n\n\nVisualizing Results With Heatmaps\nWe can also plot differentially expressed genes in the two conditions of our interest using heatmaps. In this case we select genes based on their significance and visualize how their expression values change across samples just like we have done earlier.\n\n# Take genes\ndiffs <- rbind(volcano_corr[volcano_corr$threshold == \"A\",], volcano_corr[volcano_corr$threshold == \"B\",])$gene_names\n\n# Extract counts from `dds` object\nmtx <- counts(dds, normalized=TRUE)[,rownames(samples[which(samples$SampleGroup %in% conds),])]\n\n# Subset for differential genes \nids <- rownames(volcano_corr[which(volcano_corr$gene_names %in% diffs),])\n\n# Subset matrix for genes of interest\nmtx <- mtx[ids,]\n\n# Create another table for annotating the heatmap with colors\ndf <- as.data.frame(colData(dds)[,c(\"Donor\",\"SampleGroup\")])\n\n# Plot with pheatmap\npheatmap(mtx, cluster_rows=TRUE, show_rownames=FALSE,\n         cluster_cols=TRUE, annotation_col=df[which(rownames(df) %in% colnames(mtx)),], scale = \"row\")\n\n\n\n\n\n\n\n\nGiven that the number of differentially expressed genes can sometimes be very high, we cannot pretend to explore them manually one by one understanding their function! As we will see, there are further downstream analyses we can perform to get a sense of trends and pathways activated in the cell type of our interest. These analyses which look at genes in groups or ontologies try to match conditions with functions, to better elucidate what is going on inside cells in a specific condition."
  },
  {
    "objectID": "pages/day3.html#further-downstream-analyses",
    "href": "pages/day3.html#further-downstream-analyses",
    "title": "Day 3",
    "section": "Further Downstream Analyses",
    "text": "Further Downstream Analyses\nOnce we have our differentially expressed genes, we can perform various downstream analyses to check the functional aspects of the group of genes which are up- or down-regulated in our condition of interest. In the following sections, we will go through two of these, Gene Set Enrichment Analysis (GSEA) and Gene Ontology Enrichment Analysis (GO).\n\nGSEA\nGene Set Enrichment Analaysis was first published in 2005 as a method to interpret genome-wide expression profiles from RNA-seq data using sets of genes with known biological functions. In this sense, GSEA is used to check at which level a signature of genes is enriched in an expression profile. We can graphically summarize the steps in GSEA using the following picture, from the original publication.\n\n\nGSEA needs two ingredients, a ranked gene list from our analysis (for instance genes ordered by log-fold change) and a list of genes with biological relevance (for instance genes known to regulate CD8+ T-cell exhaustion).\n\n1. We start by taking our list of up- or down- regulated genes and order them based on the value of the fold-change so that our list will have genes that change a lot at the top and ones with little change at the bottom. This will represent our ranking.\n2. We then take one or more curated and archived gene sets which are related to a biological function we might be interested in investigating in our dataset.\n3. Finally we go through our ranking from top to bottom counting the number of times we see a gene which is also in the gene set that we are looking at. We expect to see genes from a given gene set appear at the top of our ranking if that biological function is particularly important in the genes of our ranking.\nOver the years, a collection of curated gene sets called MSigDB has been expanded and is now a great resource to check which ones are more or less enriched in our data at hand.\n\n\nThe web interface for the MSigDB gene set database\n\nIn our specific use case, we are going to run GSEA on the set of up-regulated genes in CD8+ Tex cells to check if a gene set of exhaustion is indeed enriched in the genes we have found up-regulated. For this task we are going to use the fgsea package. In order to extract the gene set without the need to directly download it, we are going to access MSigDB directly from R using another package called msigdbr.\nIn the following chunk, we use a function from the msigdbr package to extract the gene set of our interest:\n\nlibrary(msigdbr)\n\n# Extract the gene sets from the MSigDB database\nimmune_gsets <- msigdbr(species = \"human\", category = \"C7\", subcategory = \"IMMUNESIGDB\")\n\nLet‚Äôs see what‚Äôs in the immune_gsets object:\n\n# Take a look at what we fetched from the database\nhead(immune_gsets, 5)\n\n# A tibble: 5 √ó 15\n  gs_cat gs_subcat gs_name gene_‚Ä¶¬π entre‚Ä¶¬≤ ensem‚Ä¶¬≥ human‚Ä¶‚Å¥ human‚Ä¶‚Åµ human‚Ä¶‚Å∂ gs_id\n  <chr>  <chr>     <chr>   <chr>     <int> <chr>   <chr>     <int> <chr>   <chr>\n1 C7     IMMUNESI‚Ä¶ GOLDRA‚Ä¶ ABCA2        20 ENSG00‚Ä¶ ABCA2        20 ENSG00‚Ä¶ M3044\n2 C7     IMMUNESI‚Ä¶ GOLDRA‚Ä¶ ABCC5     10057 ENSG00‚Ä¶ ABCC5     10057 ENSG00‚Ä¶ M3044\n3 C7     IMMUNESI‚Ä¶ GOLDRA‚Ä¶ ABHD14A   25864 ENSG00‚Ä¶ ABHD14A   25864 ENSG00‚Ä¶ M3044\n4 C7     IMMUNESI‚Ä¶ GOLDRA‚Ä¶ ACADM        34 ENSG00‚Ä¶ ACADM        34 ENSG00‚Ä¶ M3044\n5 C7     IMMUNESI‚Ä¶ GOLDRA‚Ä¶ ACP5         54 ENSG00‚Ä¶ ACP5         54 ENSG00‚Ä¶ M3044\n# ‚Ä¶ with 5 more variables: gs_pmid <chr>, gs_geoid <chr>,\n#   gs_exact_source <chr>, gs_url <chr>, gs_description <chr>, and abbreviated\n#   variable names ¬π‚Äãgene_symbol, ¬≤‚Äãentrez_gene, ¬≥‚Äãensembl_gene,\n#   ‚Å¥‚Äãhuman_gene_symbol, ‚Åµ‚Äãhuman_entrez_gene, ‚Å∂‚Äãhuman_ensembl_gene\n\n\nWe can see that every row is a different gene (the gene_symbol colums) with its associated gene set (gs_name column). We will now extract a gene set related to CD8+ T-cell exhaustion which comes from this publication and is names GSE9650_EFFECTOR_VS_EXHAUSTED_CD8_TCELL_DN in the database.\n\n# Filter the `immune_gsets` table and take only the genes from the gene set of our interest\ngene_set_name <- \"GSE9650_EFFECTOR_VS_EXHAUSTED_CD8_TCELL_DN\"\ntex_sig_df <- immune_gsets %>% filter(gs_name == gene_set_name)\n\nHow many genes do we have in the gene set that we just isolated? We can check this by looking at the number of rows of this new tex_sig_df table that we generated above using the command nrow(tex_sig_df). Doing this should result in having 232 genes. Now we can perform GSEA!\n\nlibrary(fgsea)\n\n# Prepare the ranking\nids <- rbind(up_df, down_df) %>% arrange(desc(log2FoldChange)) %>% rownames()\nvals <- rbind(up_df, down_df) %>% arrange(desc(log2FoldChange)) %>% pull(log2FoldChange)\n\n# Set names\nnames(vals) <- ids \n\n# Prepare gene set\ngset <- list(tex_sig_df$ensembl_gene)\nnames(gset) <- gene_set_name\n\n# Run GSEA\nfgseaRes <- fgsea(pathways = gset, \n                  stats    = vals,\n                  eps      = 0.0)\n\n# Take a look at results\nhead(fgseaRes[order(pval), ])\n\n                                      pathway        pval        padj   log2err\n1: GSE9650_EFFECTOR_VS_EXHAUSTED_CD8_TCELL_DN 0.003359401 0.003359401 0.4317077\n           ES       NES size\n1: -0.4026631 -1.897667   48\n                                                                                           leadingEdge\n1: ENSG00000115008,ENSG00000205002,ENSG00000178695,ENSG00000143333,ENSG00000067208,ENSG00000196664,...\n\n\nUnfortunately, we can see that the results do not really match with our expectation, let‚Äôs plot the enrichment on a standard GSEA results plot.\n\n# Plot GSEA results\nplotEnrichment(gset[[gene_set_name]],\n               vals) + labs(title=gene_set_name)\n\n\n\n\n\n\n\n\nFrom the GSEA results, we can see that the current gene set we used is mostly depleted in the differential genes we have in our CD8+ Ttumor vs CD8+ Teff comparison. Given that the gene set comes from a study carried out in mice in a context of chronic viral infection, this might indicate that our current results reflect a different kind of CD8+ T-cell exhaustion observed in the tumor microenvironment of human tumors as opposed to the process happening during viral infection in mice.\n\nüí° Whenever we use gene sets when testing for enrichment, we have to be sure of where they were isolated in order to avoid misinterpreting results and/or getting to wrong conclusions, like it could have happened in this case!\n\n\n\nGene Ontology Enrichment Analysis\nNext, we will try to get a more unsupervised look at what kind of biology is happening inside our CD8+ Tex cells by performing a Gene Ontology Enrichment analysis. This will allow us to check which and how many up-regulated genes in CD8+ Tex cells are represented in various biological processes. We will do this using the clusterProfiler package in R.\n\nlibrary(clusterProfiler)\n\n# Get up-regulated genes\ngenes <- rownames(up_df)\n\n# Perform gene ontology enrichment\nego <- enrichGO(gene         = genes,\n                OrgDb         = org.Hs.eg.db,\n                keyType       = 'ENSEMBL',\n                ont           = \"MF\", # Molecular Function, use \"BP\" or \"CC\" for Biological Process or Cellular Component\n                pAdjustMethod = \"BH\",\n                pvalueCutoff  = 0.05,\n                qvalueCutoff  = 0.05,\n                readable      = TRUE)\n\n# Inspect the results of gene ontology enrichment analysis\nhead(ego)\n\n                   ID                                         Description\nGO:0001637 GO:0001637 G protein-coupled chemoattractant receptor activity\nGO:0004950 GO:0004950                         chemokine receptor activity\nGO:0016493 GO:0016493                     C-C chemokine receptor activity\nGO:0019957 GO:0019957                               C-C chemokine binding\nGO:0019956 GO:0019956                                   chemokine binding\nGO:0005085 GO:0005085          guanyl-nucleotide exchange factor activity\n           GeneRatio   BgRatio       pvalue     p.adjust       qvalue\nGO:0001637   13/1549  26/20616 9.519909e-09 4.917033e-06 4.579577e-06\nGO:0004950   13/1549  26/20616 9.519909e-09 4.917033e-06 4.579577e-06\nGO:0016493   12/1549  23/20616 1.922635e-08 6.620272e-06 6.165923e-06\nGO:0019957   12/1549  24/20616 3.581701e-08 9.249743e-06 8.614934e-06\nGO:0019956   13/1549  33/20616 3.184750e-07 6.579694e-05 6.128130e-05\nGO:0005085   38/1549 237/20616 7.182273e-06 1.236548e-03 1.151684e-03\n                                                                                                                                                                                                                                                               geneID\nGO:0001637                                                                                                                                                                                  CXCR3/CCR6/CXCR6/CCR3/CCR2/CCR5/CX3CR1/XCR1/CCR1/CMKLR1/ACKR3/GPR75/CXCR1\nGO:0004950                                                                                                                                                                                  CXCR3/CCR6/CXCR6/CCR3/CCR2/CCR5/CX3CR1/XCR1/CCR1/CMKLR1/ACKR3/GPR75/CXCR1\nGO:0016493                                                                                                                                                                                         CXCR3/CCR6/CXCR6/CCR3/CCR2/CCR5/CX3CR1/XCR1/CCR1/ACKR3/GPR75/CXCR1\nGO:0019957                                                                                                                                                                                         CXCR3/CCR6/CXCR6/CCR3/CCR2/CCR5/CX3CR1/XCR1/CCR1/ACKR3/CXCR1/ZFP36\nGO:0019956                                                                                                                                                                                   CXCR3/CCR6/CXCR6/CCR3/CCR2/CCR5/CX3CR1/XCR1/CCR1/ITGA4/ACKR3/CXCR1/ZFP36\nGO:0005085 FGD1/RIN2/PREX1/OBSCN/DENND2D/ARHGEF11/RGL2/TAGAP/IQSEC1/SH3BP5/ARHGEF3/CYTH3/RASGRP2/RAPGEF2/FLCN/ARHGEF18/PLEKHG2/ARHGEF1/TBXA2R/SH2D3A/FGD3/RALGDS/MCF2L/RCBTB2/DOCK9/PLEKHG3/RAPGEF6/BCR/RGL4/CYTH4/SBF1/KNDC1/RASGEF1A/HPS1/AKAP13/GDPGP1/HERC2/HERC1\n           Count\nGO:0001637    13\nGO:0004950    13\nGO:0016493    12\nGO:0019957    12\nGO:0019956    13\nGO:0005085    38\n\n\nLet‚Äôs now plot the enrichment values that we got with a graph layout.\n\n# Plot results of gene ontology enrichment\ngoplot(ego, firstSigNodes=10)\n\n\n\n\n\n\n\n\nNow we can also plot the results with what is known as a ranked dot plot, here we encode the significance of the enrichment in the color of the dot, while its size represent the overlap of the specific gene set with the one we are using to perform the test (our list of up-regulated genes).\n\ndotplot(ego, showCategory=20) + ggtitle(\"Dotplot for GO enrichment\")\n\n\n\n\n\n\n\n\n\nüí° GO analyses might higlight very interesting patterns and generate hypotheses, but are many times quite hard to interpret depending also on the biological system we are studying."
  },
  {
    "objectID": "pages/index.html#how-to-reach-us",
    "href": "pages/index.html#how-to-reach-us",
    "title": "Introduction",
    "section": "How To Reach Us",
    "text": "How To Reach Us\n\nJacopo Arrigoni (jacopo.arrigoni@ifom.eu)\nMattia Toninelli (mattia.toninelli@ifom.eu)"
  }
]